# 33-Search-in-Rotated-Sorted-Array

1. 先通过二分法找到最小的一个。（后面部分的开头）
> 因为后面的部分永远小于前面的部分（也就小于第一项），所以如果nums[mid]比nums[hi]大，那么就在[mid+1,hi]之间，否则在[lo,mid]之间。

2. 使用二分查找
重点：需要求得真实的mid的位置，通过公式

```
realMid = (mid+rot)%len; // 原理是开头是第rot个，其他同理。
```

然后比较值，大的，hi=mid-1，反之，lo=mid+1。

**注意：二分条件是lo<=hi，因为1中是数组中两个不同索引比大小，因为相同索引必然相同所以可以去掉，而这个是和给定的比较，不能去掉**